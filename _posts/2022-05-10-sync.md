---

layout: single  
title: "Synctools"  
date: 2022-05-11 17:54:00 +0800   
categories: Go Go-Base

---
# sync.Mutex（互斥锁）

* 同步的用途有两个，一个是避免多个线程在同一时刻操作同一个数据块，另一个是协调多个线程，以避免它们在同一时刻执行同一个代码块。
* 共享资源包括数据块，代码块。同步就是控制多个线程对共享资源的访问。
* 只能多线程串行化访问的代码块被称为临界区。
* 互斥量或者互斥锁（mutex）为其中一种同步工具。
* 使用互斥锁的注意事项如下：
	* 不要重复锁定互斥锁；
	* 不要忘记解锁互斥锁，必要时使用defer语句；
	* 不要对尚未锁定或者已解锁的互斥锁解锁；
	* 不要在多个函数之间直接传递互斥锁。
* 由 Go 语言运行时系统自行抛出的 panic 都属于致命错误，都是无法被恢复的，调用recover函数对它们起不到任何作用。也就是说，`sync.Mutex`一旦产生死锁，程序必然崩溃。
* 避免死锁：让每一个互斥锁都只保护一个临界区或一组相关临界区，而不是多个临界区。
* `sync.Mutex`是一个结构体类型，属于值类型中的一种。把它传给一个函数、将它从函数中返回、把它赋给其他变量、让它进入某个通道都会导致它的副本的产生。

# sync.RWMutex（读写锁）

* sync.RWMutex类型中的Lock方法和Unlock方法分别用于对写锁进行锁定和解锁，而它的RLock方法和RUnlock方法则分别用于对读锁进行锁定和解锁。读锁之间不互斥。
* 对写锁进行解锁，会唤醒“所有因试图锁定读锁，而被阻塞的 goroutine”，并且，这通常会使它们都成功完成对读锁的锁定。
* 处于获取锁等待阻塞的 goroutines，谁的等待时间最长，谁就先被唤醒。
* 递归读锁定（recursive read locking）：如果goroutine1 获取读写锁的读锁后，goroutine2获取写锁阻塞，这时之后新的goroutine获取读锁会阻塞直到goroutine1 读锁被释放。这是为了确保读写锁的写锁可用。

# sync.Cond（条件变量）

* **首先，Wait前为什么需要加锁？因为存在多个goroutine并发调用同一个条件变量的Wait会有资源竞争，共享资源应该是条件变量维护的通知队列。其次，为什么要在Wait中先解锁呢？因为竞争资源已经拿到并处理完了（goroutine加入到通知队列），下一步该goroutine要处于等待状态之前必须释放锁，以供其他goroutine获取该锁做其他事情？（待验证）**
* 互斥锁是对一个共享区域进行加锁，所有线程都是一种竞争的状态去访问，而条件变量主要是通过条件状态来判断，实际上他还是会阻塞 只不过不会像互斥锁一样去参与竞争，而是在那里等待条件变量的状态发生改变过后的通知再被唤醒。
* 条件变量主要是用于协调想要访问共享资源的那些线程。当共享资源的状态发生变化时，它可以被用来通知被互斥锁阻塞的线程，它既可以基于互斥锁，也可以基于读写锁。
* sync.Cond类型的值一旦被使用就不应该再被传递了，传递往往意味着拷贝。拷贝一个已经被使用过的 sync.Cond 值是很危险的，因为在这份拷贝上调用任何方法都会立即引发 panic（nocopy限制）。但是它的指针值是可以被拷贝的。
* 条件变量提供的方法有三个：等待通知（wait）、单发通知（signal）和广播通知（broadcast）。
* 一个条件变量可以实现单向的通知，而双向的通知则需要两个条件变量。
* 条件变量单向通知的简单应用场景：生产-消费协作。
* wait方法流程：
	* 把当前goroutine加入到当前条件变量的通知队列中；
	* 解锁当前条件变量基于的互斥锁；
	* 让当前goroutine处于等待状态，等到通知到来时再决定是否唤醒它；
	* 等到通知到来并且决定唤醒这个 goroutine，那么就在唤醒它之后重新锁定当前条件变量基于的互斥锁。
* if语句只会对共享资源的状态检查一次，而for语句却可以做多次检查，直到这个状态改变为止。所以wait方法外层检查用for语句。原因如下：
	* 有多个 goroutine 在等待共享资源的同一种状态。比如：如果一个 goroutine 因收到通知而被唤醒，但却发现共享资源的状态，依然不符合它的要求，那么就应该再次调用条件变量的Wait方法，并继续等待下次通知的到来。
	* 共享资源可能有的状态不是两个，而是更多。比如：状态结果有1，2，3，4四种情况，由于状态在每次改变后的结果只可能有一个，所以，在设计合理的前提下，单一的结果一定不可能满足所有 goroutine 的条件。那些未被满足的 goroutine 显然还需要继续等待和检查。
	* 在一些多 CPU 核心的计算机系统中，即使没有收到条件变量的通知，调用其Wait方法的 goroutine 也是有可能被唤醒的。
* 条件变量的Signal方法和Broadcast方法都是被用来发送通知的，不同的是，前者的通知只会唤醒一个因此而等待的 goroutine，而后者的通知却会唤醒所有为此等待的 goroutine。我们最好在解锁条件变量基于的那个互斥锁之后，再去调用它的这两个方法。**这可以有效防止Wait 方法的调用方错过通知，更有利于程序的运行效率。**
* 条件变量的通知具有即时性。也就是说，如果发送通知的时候没有 goroutine 为此等待，那么该通知就会被直接丢弃。在这之后才开始等待的 goroutine 只可能被后面的通知唤醒。

# sync.atomic（原子性）

* Go运行时系统调度goroutine，让其由运行状态转为非运行状态，即**中断执行**。
* 互斥锁虽然可以保证临界区中代码的串行执行，但却不能保证这些代码执行的原子性（atomicity）。
* 与其他的同步工具相比，原子操作不能被中断，所以它需要足够简单，并且要求快速。
* 操作系统层面只对针对二进制位或整数的原子操作提供了支持。Go 语言的原子操作当然是基于 CPU 和操作系统的，所以它也只针对少数数据类型的值提供了原子操作函数。这些函数都存在于标准库代码包sync/atomic中。
* sync/atomic包中的函数可以做的原子操作有：加法（add）、比较并交换（compare and swap，简称 CAS）、加载（load）、存储（store）和交换（swap）。不过，针对unsafe.Pointer类型，该包并未提供进行原子加法操作的函数。sync/atomic包还提供了一个名为Value的类型，它可以被用来存储任意类型的值。此类型值含有Load和Store方法，有如下规则：
	* Store不能存储nil；
	* Store存储的第一个值，决定了它今后能且只能存储哪一个类型的值。

		**注意**：我们无法通过某个方法获知一个原子值是否已经被真正使用，并且，也没有办法通过常规的途径得到一个原子值可以存储值的实际类型。这使得我们误用原子值的可能性大大增加，尤其是在多个地方使用同一个原子值的时候。
* sync/atomic包还提供了一个名为Value的类型使用建议：
	* 不要把内部使用的原子值暴露给外界。比如，声明一个全局的原子变量并不是一个正确的做法。这个变量的访问权限最起码也应该是包级私有的。
	* 如果不得不让包外，或模块外的代码使用你的原子值，那么可以声明一个包级私有的原子变量，然后再通过一个或多个公开的函数，让外界间接地使用到它。注意，这种情况下不要把原子值传递到外界，不论是传递原子值本身还是它的指针值。
	* 如果通过某个函数可以向内部的原子值存储值的话，那么就应该在这个函数中先判断被存储值类型的合法性。若不合法，则应该直接返回对应的错误值，从而避免 panic 的发生。
	* 如果可能的话，我们可以把原子值封装到一个数据类型中，比如一个结构体类型。这样，我们既可以通过该类型的方法更加安全地存储值，又可以在该类型中包含可存储值的合法类型信息。
* 自旋锁（spinlock）：适用共享资源状态的改变并不频繁的场景。
	```

		for {
		 if atomic.CompareAndSwapInt32(&num2, 10, 0) {
		  fmt.Println("The second number has gone to zero.")
		  break
		 }
		 time.Sleep(time.Millisecond * 500)
		}
	```	
* 对一个共享资源进行保护，那就要做到完全原子性的保护，即读写操作都要原子性。
* 每个G（goroutine）都需要在某个M（系统线程）上运行，而每个M都需要在某个CPU核心中运行。
* 在同一时刻，Go调度器中的G有很多，但是正在运行的G的数量不会多于M数。如果当前所有的M都忙不过来了，那么Go调度器就会马上生成新的M。
* Go语言调度模型中的P最好与CPU核心数相等。 因为一个P就代表着一条调度线。可以说，它会不断地把其队列中的G喂给M。反过来讲，每个M一旦饿了（处于空闲状态）就会向调度器要吃的（可运行的G）。
基于此，如果调度线太少，那么这个调度模型的效率就无法完全体现，一些CPU核心就会比较闲；但如果调度线太多，那调度器调度的可运行G又会导致很多M产生，而这些M又会多到CPU核心忙不过来（反而会影响效率）。

# sync.WaitGroup and sync.Once

* sync包的WaitGroup类型。它比通道更加适合实现这种一对多的 goroutine 协作流程。
* WaitGroup值中计数器的值不能小于0，是因为这样会引发一个 panic。调用Add方法的时候是可以传入一个负数的。

	![sync.WaitGroup的计数周期.png](/assets/img/sync.WaitGroup的计数周期.png)
	
* 如果在一个此类值的Wait方法被执行期间，跨越了两个计数周期，那么就会引发一个 panic。
* 不要把增加其计数器值的操作和调用其Wait方法的代码，放在不同的 goroutine 中执行。换句话说，要杜绝对同一个WaitGroup值的两种操作的并发执行。
* Do方法在参数函数执行结束后，对done字段的赋值用的是原子操作，并且，这一操作是被挂在defer语句中的。因此，不论参数函数的执行会以怎样的方式结束，done字段的值都会变为1。也就是说，即使这个参数函数没有执行成功（比如引发了一个 panic），我们也无法使用同一个Once值重新执行它了。所以，如果你需要为参数函数的执行设定重试机制，那么就要考虑Once值的适时替换问题。
* Once类型使用互斥锁和原子操作实现了功能，而WaitGroup类型中只用到了原子操作。 所以可以说，它们都是更高层次的同步工具。

# context.Context

* Context类型是一种非常通用的同步工具。它的值不但可以被任意地扩散，而且还可以被用来传递额外的信息和信号。此类值是并发安全。
* 由于Context类型实际上是一个接口类型，而context包中实现该接口的所有私有类型，都是基于某个数据类型的指针类型，所以，如此传播并不会影响该类型值的功能和安全。
* 子contex可以携带其父值的属性和数据，也可以响应我们通过其父值传达的信号。
* 在撤销函数被调用之后，对应的Context值会先关闭它内部的接收通道，也就是它的Done方法会返回的那个通道。然后，它会向它的所有子值（或者说子节点）传达撤销信号。这些子值会如法炮制，把撤销信号继续传播下去。最后，这个Context值会断开它与其父值之间的关联。
* 调用context.WithValue函数得到的Context值是不可撤销的。撤销信号在被传播时，若遇到它们则会直接跨过，并试图将信号直接传给它们的子值。
* Context接口并没有提供改变数据的方法。因此，在通常情况下，我们只能通过在上下文树中添加含数据的Context值来存储新的数据，或者通过撤销此种值的父值丢弃掉相应的数据。如果你存储在这里的数据可以从外部改变，那么必须自行保证安全。
* Context值在传达撤销信号的时候是深度优先的。
* 不要存储context在一个结构体类型中。
* [go管道](https://blog.golang.org/pipelines)
* [go上下文](https://blog.golang.org/context)

# sync.Pool

* sync.pool：临时对象池，对某类值或者数据的缓存，可以帮助程序实现可伸缩性（需要时可以拿到，不需要时自动清理），减轻垃圾回收器的压力。
* 如果当前的池中没有任何值，那么Get方法就会使用当前池的New字段创建一个新值，新值并不会被存入当前的临时对象池中，而是直接返回给Get方法的调用方。New字段的实际值需要我们在初始化临时对象池的时候就给定。否则，在我们调用它的Get方法的时候就有可能会得到nil。
* 临时对象池中的每一个值都是独立的、平等的和可重用的。
* sync包在被初始化的时候，会向 Go 语言运行时系统注册一个函数，这个函数的功能就是清除所有已创建的临时对象池中的值。我们可以把它称为池清理函数。
* 池清理函数会遍历池汇总列表。对于其中的每一个临时对象池，它都会先将池中所有的私有临时对象和共享临时对象列表都置为nil，然后再把这个池中的所有本地池列表都销毁掉。最后，池清理函数会把池汇总列表重置为空的切片。
* 本地池列表是一个数组。这个列表的长度，总是与 Go 语言调度器中的 P 的数量相同。作用：分散存储和性能的压力。
* 在程序调用临时对象池的Put方法或Get方法的时候，总会先试图从该临时对象池的本地池列表中，获取与之对应的本地池，依据的就是与当前的 goroutine 关联的那个 P 的 ID。
* 一个本地池的shared字段原则上可以被任何 goroutine 中的代码访问到，不论这个 goroutine 关联的是哪一个 P。一个本地池的private字段，只可能被与之对应的那个 P 所关联的 goroutine 中的代码访问到，它是 P 级私有的。
* Get方法都会去访问当前的临时对象池中的所有本地池，它会去逐个搜索它们的共享临时对象列表。

	![sync.pool获取临时对象](/assets/img/sync.pool获取临时对象.png)

* 临时对象池存储的临时对象都应该是拥有较长生命周期的值，并且，这些值不应该被某个 goroutine 中的代码长期的持有和使用。
* STW 是 Stop The World 的缩写，在这里的含义是：当 GC 进行到某个关键步骤时需要停止一切调度工作以及 goroutine 的一般运行工作。

# sync.Map

* sync.Map与原生map明显不同，它只是 Go 语言标准库中的一员，而不是语言层面的东西。Go 语言的编译器并不会对它的键和值，进行特殊的类型检查。它所有的方法涉及的键和值的类型都是interface{}，也就是空接口。所以，我们必须在程序中自行保证它的**键类型**和值类型的正确性。
* 我们应该在每次操作并发安全字典的时候，都去显式地检查键值的实际类型。无论是存、取还是删，都应该如此。参照原生字典的，sync.Map键的实际类型不能是函数类型、字典类型和切片类型。
* 相比map+Mutex或者RWMutex，sync.Map在这两个使用场景下：少些多读；多goroutine读写，覆盖写；将会减少锁的争用，因为先读的是read字典，不用mutex，是原子读操作，覆盖写并且没有被逻辑删除，也是不同mutex，而是原子存储操作。
* 完全确定键和值的具体类型的情况：使用类型断言表达式来做键值的类型检查。（缺陷：无法灵活地改变字典的键和值的类型，一旦需求出现多样化，会带来重复编码。）
* 反射操作：封装的并发安全字典结构体增加键类型和值类型字段，此字段为`reflect.Type`类型，这两个字段必须在初始化的时候就完全确定。对应方法中增加反射类型检查即可。（缺陷：反射操作或多或少都会降低程序的性能。）
* read字典包含sync.Map字典的部分键值对，读取整个readOnly对象不需要mutex。只读取意思是键不能改变，但可修改键值。
* dirty字典包含sync.Map字典的部分键值对，包含所有在read字典中为未删除状态的entry。
* sync.Map的读取：先read字典中查找，没有再去dirty字典中查找。
* sync.Map的存储：先检查read字典中是否有这个键，若有并且该键值对未被标记为“已删除”，就会把新值存到里面并直接返回，否则，它才会在锁的保护下把键值对存储到脏字典中，同时在read字典中该键值对的“已删除”标记会被抹去，即存储新值。  
 
	![sync.Map中的read与dirty](/assets/img/sync.Map中的read与dirty.png)
	
* sync.Map的删除：先检查read字典中是否有对应的键。如果有，将entry.p设为nil，如果没有，则试图从dirty字典中删掉该键值对。dirty字典删除键值对的方式是另一种逻辑删除（即原生map的删除key的方式）：将m.dirty[key] 设为e，m.dirty[key].p设为nil。
* read字典和dirty字典的转换：dirty拷贝到read时，其中删除状态的键值对entry对应的p字段会变为expunged，即将entry.p=nil 改为entry.p=expunged。最后dirty字典设为nil。一旦再有新的键值对存入，它就会依据reaad字典去重建dirty字典。这个时候，它会把read字典中已被逻辑删除的键值对过滤掉。理所当然，这些转换操作肯定都需要在锁的保护下进行。

	![sync.Map中read与dirty的互换](/assets/img/sync.Map中read与dirty的互换.png)
	
* **atomic.Value 类型的值（以下简称“value”吧）只能保证（完整地）存/取操作的原子性。比如，你在里面存一个 map，它只能保证存这个 map 或取这个 map 的时候是原子操作，但你如果要存、取、改、删这个 map 里的键值对，那 value 就管不到了（这时就会是非原子的操作）**。

