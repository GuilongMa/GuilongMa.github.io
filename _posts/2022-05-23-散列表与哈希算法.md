---

layout: single  
title: "散列表与哈希算法"  
date: 2022-05-24 00:19:00 +0800   
categories: algorithm

---

# 散列表

* 散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。
* 散列函数设计的基本要求：
	* 散列函数计算得到的散列值是一个非负整数；
	* 如果 key1 = key2，那 hash(key1) == hash(key2)；
	* 如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)。
* 即便像业界著名的MD5、SHA、CRC等哈希算法，也无法完全避免这种散列冲突。而且，因为数组的存储空间有限，也会加大散列冲突的概率。
* 装载因子：散列表的装载因子=填入表中的元素个数/散列表的长度。装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。
* 散列冲突解决办法：
	* 开放寻址法：
		* 线性探测：探测的下标序列：hash(key)+0，hash(key)+1，hash(key)+2，冲突位置依次往后找，直到有空的位置为止，如果到达表尾，则从表头继续。
		* 二次探测（Quadratic probing）：探测的下标序列：hash(key)+0，hash(key)+12，hash(key)+22……
		* 双重散列（Double hashing）：使用一组散列函数 hash1(key)，hash2(key)，hash3(key)……先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。
	* 链表法：在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。
* 设计工业级散列表：
	* 散列函数不能太复杂，散列函数生成的值尽可能随机且均匀分布以减少冲突
	* 装载因子太大会导致冲突过多，太小会让内存浪费，当超过一定阈值，散列表则需要进行动态扩容，需搬移数据（若数据量较大，可以分多次搬移，这样避免低效的扩容，但查询时需先在新的散列表查找，没有再去旧的散列表查找）。
	* 开放性寻址法优缺点：
		* 存储在数组中，适合缓存和序列化
		* 删除时需要特殊标记已经删除掉的数据
		* 装载因子不能太大，散列表更浪费内存空间。
		* 适用场景：数据量比较小，装载因子小
	* 链表法优缺点：
		* 链表法对内存的利用率比开放寻址法要高
		* 存储在链表中，链表节点可以需要的时候创建
		* 装载因子可以大于1，只要散列函数的值随机均匀，则装载因子对查找效率影响较小
		* 对缓存不友好
		* 适用场景：存储大对象、大数据量的散列表，更加灵活，可用红黑树或者跳表代替链表。
	* 工业级散列表特性：
		* 支持快速查找，插入，删除操作
		* 内存占用合理，不浪费过多的内存空间
		* 性能稳定
		* 散列表和链表的组合应用：
			* LRU：散列表和双向链表
			* Redis有序集合：散列表和跳表
		* 散列表和链表（或者跳表）结合在一起使用，使得散列表可以顺序遍历。

# 哈希算法 

* 哈希算法：将任意长度的二进制数据值串映射为固定长度的二进制值串，此映射规则则为哈希算法。
* 比如：MD5（哈希值为128bit，转化为十六进制，则为32个字符）， SHA等。
* 哈希算法应用：
	* 安全加密：MD5（消息摘要算法），SHA（安全散列算法），DES（数据加密算法）AES（高级加密标准）。（理由：根据哈希值很难反推出原始数据；散列冲突的概率很小）
	* 唯一标识：图片的查找
	* 数据校验：数据下载求哈希值，与种子中的哈希值比较
	* 散列函数：均匀分布，不复杂，计算快速，允许冲突，不关心反向解密。
	* 负载均衡：客户端IP地址计算哈希值，哈希值与服务器列表的大小进行取模运算，求得的值即为被路由的服务器编号。
	* 数据分片：对大量的数据进行分片，计算哈希值，与处理机器数量进行取模运算，得到的值即为被分配到的机器编号，故重复的数据会被分配到相同的机器上进行处理。
	* 分布式存储：一致性哈希算法（解决扩容带来的重新哈希和大量数据搬移的问题）