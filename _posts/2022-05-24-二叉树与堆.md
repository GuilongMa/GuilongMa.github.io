---

layout: single  
title: "二叉树与堆"  
date: 2022-05-24 15:19:00 +0800   
categories: algorithm

---

# 树

* 二叉树为非线性结构，节点高度：节点到叶子节点的最长路径；节点深度：根节点到此节点的路径长度（即边的个数）；节点的层数：节点深度+1，树的高度：根节点的高度。

	![树的概念](/assets/img/树的概念.jpg)
	
	注意：高度和深度计数起点为0，而层数计数起点为1。

* 常见种类：满二叉树，完全二叉树。
* 完全二叉树：最后一层的叶子节点都靠左排列，除最后一层，其他层的节点个数都达到最大。
* 存储二叉树：一种是二叉链式存储法，另一种是数组的顺序存储法（根节点存储在下标为i=1的位置，0位置为空，则左节点下标为2*i，右节点为2*i+1，节点i的父节点为i/2，适合完全二叉树，紧凑，不浪费空间）。
* 二叉树的遍历：
	* 前序遍历：先打印中间节点，再打印左节点，最后打印右节点。
	* 中序遍历：先打印左节点，再打印中间节点，最后打印右节点。
	* 后序遍历：先打印左节点，再打印右节点，最好打印中间节点。
	* 层次遍历：从上到下，从左到右打印节点。
	* 每个节点最多被访问两次（**一次判断是否为空，一次为输出**），时间复杂度为O(n)。
* 二叉查找树：任意一个节点，左子树中的节点值都小于此节点值，右子树中的节点值都大于此节点值。
	* 支持动态数据集合的快速插入、删除、查找操作，最好时间复杂度为O(logn)。
	* 二叉查找树的查找操作：从根节点开始查找，如果等于查找的节点，则返回，如果小于查找的节点，则从左子树递归查找，如果大于查找的节点，则从右子树递归查找。
	* 二叉查找树的插入操作：类似查找操作，从根节点开始比较，若大于根节点且右子树为空，则插入到右节点的位置，右子树不为空，则继续递归遍历比较右子树，若小于根节点且左子树为空，则插入到左节点的位置，左子树不为空，则继续递归遍历比较左子树。
	* 二叉查找树的删除操作：分三种情况：
		* 要删除的节点没有子节点，则只需要将删除的节点的父节点指向空。
		* 要删除的节点只有一个子节点（左节点或者右节点），只需要更新父节点，将父节点指向要删除节点的子节点就可以。
		* 要删除节点有两个子节点，需要找到此删除节点的右子树中的最小节点，把其值替换到要删除的节点，然后删除此最小节点，因为最小节点肯定没有左节点，故删除此最小节点可看成要删除的节点只有一个子节点或者没有子节点的情况。
		* 删除的另一种操作是标记节点为”已删除“，节点仍保留在内存中，没有释放，虽浪费内存空间，但不影响插入，查找操作的代码实现。
	* 二叉查找树支持快速查找最大节点和最小节点。
	* 二叉查找树中序遍历可以输出有序的数据序列，时间复杂度为O(n)，故又叫二叉排序数。
	* 二叉查找树插入重复的数据：①链表或者支持动态扩容的数组等数据结构存储重复的数据。②当作大于此节点来处理，即插入右子树中。
	
* 平衡二叉树：任意一个节点的左右子树的高度相差不大于1.
	* 为了保持插入，删除，查找时间复杂度稳定为O(logn),需要平衡二叉查找树。 
	* 平衡二叉查找树：AVL树：严格符合平衡二叉树和二叉查找树的定义。
	* 非严格的平衡二叉查找树：红黑树。
	* 红黑树定义：
		* 根节点为黑色；
		* 每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；
		* 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；
		* 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；
	* 左旋（rotate left）：围绕某个节点的左旋。
	* 右旋（rotate right）：围绕某个节点的右旋。 	
	* 红黑树的插入、删除操作会破坏红黑树的定义，具体来说就是会破坏红黑树的平衡。
	* 插入操作的平衡调整：
		* 红黑树规定，插入的节点必须是红色的。而且，二叉查找树中新插入的节点都是放在叶子节点上。
* 二叉查找树与散列表比较：
	* 散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序列。
	* 散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)。
	* 尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。
	* 散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。 

# 递归树

* 除了用**递推公式**计算时间复杂度外，也可以借助**递归树**来分析递归算法的时间复杂度。
* 递归树：将递归一层一层的分解画成树形图。
	
	![归并排序递归树](/assets/img/归并排序递归树.jpg)
	
	![快速排序递归树](/assets/img/快速排序递归树.jpg)
	
# 堆

* 堆：一种特殊的树，即完全二叉树，每个节点的值都必须大于等于其子树中每个节点的值，即每个节点的值都必须大于等于其左右子节点的值（大顶堆）。
* 应用：堆排序是一种原地非稳定的排序算法，时间复杂度为O(nlogn).
* 堆的存储：数组（从下标1开始存储数据，下标i的左节点下标为i*2，右节点为i*2+1，父节点为i/2）
* 堆的操作：
	* 插入：从下往上堆化
	* 删除：即删除堆顶元素，从上往下堆化
	* 堆化（O(logn)）：从下往上（顺着节点向上对比交换），从上往下（取出堆顶元素，将尾元素替代堆顶元素后进行堆化）
* 堆排序实现：
	* 建堆：
		* 插入数据建堆（从下往上）
		* 从第一个非叶子节点（n/2）逆序开始堆化（从上往下），时间复杂度为O(n)。
	* 排序：依次进行堆顶元素与尾元素交换后缩小堆范围再进行堆化，重复直到堆中只剩下标为1的一个元素，则输出的数组即为排好序的。
* 优缺点：
	* 没有快速排序友好，堆化是跳着访问元素的，对CPU缓存不友好。
	* 同样的数据，排序时交换次数多于快速排序，因为建堆可能会导致原数据的有序度降低，而快速排序的交换次数不会比逆序度多。
	* 堆排序为不稳定排序，因为排序的过程，存在将堆的最后一个节点跟堆顶节点互换的操作，所以就有可能改变值相同数据的原始相对顺序。
* 堆的应用：
	* 优先队列：
		* 合并有序小文件
		* 高性能定时器
	* 求topK：先维护大小为k的小顶堆，顺序遍历数组，从数组中取出数据与堆顶元素比较。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理，继续遍历数组。这样等数组中的数据都遍历完之后，堆中的数据就是前 K 大数据了。
	* 求中位数：动态数据集合的中位数会经常改变，维护两个堆，一个大顶堆，一个小顶堆，大顶堆存储排好序的前半部分数据，小顶堆存储排好序的后半部分数据，无论数据集合个数为偶数或奇数，大顶堆的堆顶元素即为中位数。新插入的元素若大于等于小顶堆堆顶元素则插入小顶堆中，否则插入大顶堆中。通过动态调整，确保大顶堆中的元素个数为n/2（n为偶数时）或者n/2+1（n为奇数 时），这样大顶堆堆顶元素就为中位数。