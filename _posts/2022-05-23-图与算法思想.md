---

layout: single  
title: "图与算法思想"  
date: 2022-05-24 17:19:00 +0800   
categories: algorithm

---

# 图

* 图是一种非线性数据结构，图中的元素称为顶点，顶点之间的关系叫边，顶点的边的条数叫做顶点的度。图分无向图、有向图（有出度和入度之分）、带权图。

## 图的存储方式

* 邻接矩阵（二维数组）：存储方式简单，直接，这让获取顶点的关系非常高效，而且方便计算，因为可以将图的运算转化为矩阵运算。
* 邻接表（时间换空间）：有邻接表和逆邻接表之分，邻接表中链表可以换成其他动态数据结构，比如散列表，跳表，红黑树或者有序动态数组用二分法查找。邻接表太大的话可以用哈希算法等数据分片方式将邻接表切割存储在不同的机器的内存上，查找时先用哈希算法定位顶点所在机器再查找。除此之外，另一种解决办法是外部存储（硬盘），比如数据库，数据库索引可以高效支持插入，删除，查找操作。

## 图的搜索

* **深度优先搜索**：借助栈来实现，回溯思想，采用递归技巧，求解路径不一定为最短路径，时间复杂度为O(E),空间复杂度为O(V),E,V分别为边数和顶点数。
* **广度优先搜索**：借助队列来实现，能求解s到t的最短路径，时间复杂度为O(E),空间复杂度为O(V),E,V分别为边数和顶点数。
* 深度优先搜索和广度优先搜索都是暴力搜索算法，适用于状态空间不大的搜索。

# 算法思想

* 四种算法思想：贪心，分治，回溯，动态规划

## 贪心

### 特征

* 此类问题：限制值，期望值，在满足限制值的情况下，期望值最大（求总体最优解，可根据步骤b看是否可分解为局部最优来求解）。
* 每次选择当前情况下，在对限制值同等贡献量的情况下，对期望值贡献量最大的数据。（局部最优）
* 适用：局部最优可得出总体最优，即前面的选择不会影响后面的选择。
* 贪心算法不一定给出总体最优解。

### 应用举例

* 背包装物品（多种物品，单价不同，每种物品数量一定，背包重量为限制值，所装物品最大价值为期望值）：最优解
* 钱币找零（多种钱币，币值不同，每种钱币数量一定，付款值为限制值，付款的钱币数量最少为期望值）：最优解
* 区间覆盖（限制值：所取区间两两不相交，期望值：最多个区间，先按照区间起始点从小到大排序区间，遍历这n个区间的起始点，每次选择右端点尽量小的区间，每次指遍历直到左端点大于最小右端点时，此时最小右端点对应的区间即为本次的选择）
* 贪心的应用：霍夫曼编码，最小生成树算法，单源最短路径算法。

## 分治

* 分治：分而治之，将原问题划分为nge规模较小的并且结构与原问题相似的子问题，递归地求解i问题，最后合并子问题的结果，合并结果就为原问题的解。

### 特征

* 子问题无相关性，区别于动态规划
* 分解有终止条件。
* 子问题结果合并为原问题的结果，复杂度不高。

### 应用举例

* 归并排序算法
* 海量数据无法一次性加载到内存，可以进行分片或者分机处理，再合并子结果。

## 回溯

### 特征

* 枚举所有可能的解，找到满足期望的解。
* 裁剪：在递归调用之前判断条件，若不满足，则停止递归。

### 应用举例

* 深度优先搜索算法
* 正则表达式匹配
* 编译原理的语法分析
* 应用举例：
	* 八皇后（逐行放棋子，每行有多种放法，对这多种合法放法进行递归调用下一行放棋子）
	* 0-1背包（背包限制重量，取物品使背包重量最大。逐个考察物品，每个物品有两种拿法：拿或者不拿，对这两种进行递归调用下一个物品）
	* 全排列

## 动态规划

### 特征

* 动态规划的由来：代替回溯算法指数级别的复杂度。
* 动态规划理论（一个模型三个特征）：
	* 模型：多阶段决策最优解模型
	* 特征：
		* 最优子结构：通过子问题的最优解推导出问题的最优解
		* 无后效性：前一状态不受后一状态的影响。
		* 重复子问题：某一层会有重复的状态。

### 动态规划的解题思路

* 备忘录法：先用回溯画出递归树（层数表示递归调用次数，每层的节点表示状态，节点函数的两个参数值分别表示选择和期望值，期望值为选择前的期望值），从递归树可以看出重复的求解状态，故可以用备忘录存储之前的状态。效率和动态规划差不多。
* 状态转移表：
	* 合并递归树每层重复的状态，下一层的状态基于上一层的状态来推导。（避免状态个数随层数呈指数级增长：选择的层数次幂，比如0-1背包为2的物品次幂）
	* 状态表存储（时间复杂度：选择*限制值）：二维数组（空间换时间），（①初始化第一个状态②从第二行遍历行：状态转移③分多种选择遍历列（期望值）：确定每层多个状态。④最后一行的倒数最接近限制值的即为期望值，因为所有状态都集中在最后一行。
	* 二维数组优化（0-1背包问题）：一维数组，从后往前遍历添加1的状态，0的状态从上一个状态保留下来。
	* 若限制值和期望值为同一变量，则限制变量可作为行，用布尔变量填充状态转移表，若期望值与限制值不为同一变量，限制变量也为行，则填充值为期望值。
* 状态转移方程：通过子问题递归求解。
	* 递归加备忘录：从原问题一直递归到最小子问题的解再回溯获得解
	* 迭代递推：从最小子问题求解开始迭代到原问题规模处得解。

### 总结

* 状态转移表法解题思路：回溯算法实现 - 定义状态 - 画递归树 - 找重复子问题 - 画状态转移表 - 根据递推关系填表 - 将填表过程翻译成代码。
* 状态转移方程法的大致思路可以概括为，找最优子结构 - 写状态转移方程 - 将状态转移方程翻译成代码。
