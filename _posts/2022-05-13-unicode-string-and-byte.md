---

layout: single  
title: "Uincode，string and byte"  
date: 2022-05-13 12:54:00 +0800   
categories: Go Go-Base

---

# Unicode

* 当一个string类型的值被转换为[]rune类型值的时候，其中的字符串会被拆分成一个一个的 Unicode 字符。
* Unicode 编码规范通常使用十六进制表示法来表示 Unicode 代码点的整数值，并使用“U+”作为前缀。比如，英文字母字符“a”的 Unicode 代码点是 U+0061。
* UTF-8 是一种可变宽的编码方案。换句话说，它会用一个或多个字节的二进制数来表示某个字符，最多使用四个字节。
* 在 Go 语言中，一个string类型的值既可以被拆分为一个包含多个字符的序列，也可以被拆分为一个包含多个字节的序列。
* 根据rune类型的声明可知，它实际上就是int32类型的一个别名类型。也就是说，一个rune类型的值会由四个字节宽度的空间来存储。它的存储空间总是能够存下一个 UTF-8 编码值。
* 一个rune类型的值在底层其实就是一个 UTF-8 编码值。
* 首先，UTF-8编码字节含义： 对于UTF-8编码中的任意字节B，如果B的第一位为0，则B独立的表示一个字符(ASCII码)； 如果B的第一位为1，第二位为0，则B为一个多字节字符中的一个字节(非ASCII字符)； 如果B的前两位为1，第三位为0，则B为两个字节表示的字符中的第一个字节； 如果B的前三位为1，第四位为0，则B为三个字节表示的字符中的第一个字节； 如果B的前四位为1，第五位为0，则B为四个字节表示的字符中的第一个字节； 因此，例如，对于中文字符“爱”来说，字节编码为e7 88 b1（对应的二进制表示为：11100111 10001000 10110001），那么根据上述规则，把这3个字节的标记位（依次是1110 10 10）去掉后，组成的bits为：0111 001000 110001（即0111 0010 0011 0001），正好是4个字节，对应上其Unicode编码\u7231。

# String

* 相比string值，strings包中的Builder类型的值的优势：
	* 已存在的内容不可变，但可以拼接更多的内容；
	* 减少了内存分配和内容拷贝的次数；
	* 可将内容重置，可重用值。
* string值虽然在内部持有一个指向字节数组的指针值和长度，但其类型仍然属于值类型。一个string值会在底层与它的所有副本共用同一个字节数组。由于这里的字节数组永远不会被改变，所以这样做是绝对安全的。与string值相比，Builder值的优势其实主要体现在字符串拼接方面。
* strings.Builder类型在使用上的约束：
	* 在已被真正使用后就不可再被复制；
	* 由于其内容不是完全不可变的，所以需要使用方自行解决操作冲突和并发安全问题。
* 已使用的Builder值不能再被复制，但是它的指针值却可以，此时需要注意操作冲突和并发安全问题。
* strings.Reader类型的值可以高效地读取字符串。
* strings.Builder里边的String方法是  
	
	```
	// 1.String returns the accumulated string.  
	func (b * Builder) String() string {   
		return * (* string)(unsafe.Pointer(&b.buf))
	}
	// 2.String returns the accumulated string.
	func (b *Builder) String() string {
		return string(b.buf)
	}
	```
1相比2：省去了类型转换的开销，效率会高很多。

# Bytes

* strings包主要面向的是 Unicode 字符和经过 UTF-8 编码的字符串，而bytes包面对的则主要是字节和字节切片。
* bytes.Buffer不但可以拼接、截断其中的字节序列，以各种形式导出其中的内容，还可以顺序地读取其中的子序列。
* 与strings.Reader类型的Len方法一样，buffer1的Len方法返回的也是内容容器中未被读取部分的长度，而不是其中已存内容的总长度。
* 无法直接得到一个Buffer值的已读计数。
* bytes.Buffer中的已读计数的大致功用如下所示：
	* 读取内容时，相应方法会依据已读计数找到未读部分，并在读取后更新计数。
	* 写入内容时，如需扩容，相应方法会根据已读计数实现扩容策略。
	* 截断内容时，相应方法截掉的是已读计数代表索引之后的未读部分。
	* 读回退时，相应方法需要用已读计数记录回退点。
	* 重置内容时，相应方法会把已读计数置为0。
	* 导出内容时，相应方法只会导出已读计数代表的索引之后的未读部分。
	* 获取长度时，相应方法会依据已读计数和内容容器的长度，计算未读部分的长度并返回。
* 读取方法：包括了所有名称以Read开头的方法，以及Next方法和WriteTo方法。
* 在扩容的时候，方法会在必要时，依据已读计数找到未读部分，并把其中的内容拷贝到扩容后内容容器的头部位置。
* 写入方法：包括了所有名称以Write开头的方法，以及ReadFrom方法。
* 截断方法Truncate：已读计数的值再加上截断参数值后得到的和，就是内容容器新的总长度。
* 读回退的方法包括：UnreadByte和UnreadRune。
* bytes.Buffer的扩容策略：先判断内容容器的剩余容量，是否足够容纳新的内容。如果可以，那么扩容代码会在当前的内容容器之上，进行长度扩充。否则，那么扩容代码可能就会用新的内容容器去替代原有的内容容器，从而实现扩容。如果当前内容容器的容量的一半，仍然大于或等于其现有长度（即未读字节数）再加上另需的字节数的和，扩容代码就会复用现有的内容容器，并把容器中的未读内容拷贝到它的头部位置。
* 对于处在零值状态的Buffer值来说，如果第一次扩容时的另需字节数不大于64，那么该值就会基于一个预先定义好的、长度为64的字节数组来创建内容容器。
* 在bytes.Buffer中，Bytes方法和Next方法都可能会造成内容的泄露。原因在于，它们都把基于内容容器的切片直接返回给了方法的调用方。故在传出切片这类值之前要做好隔离。比如，先对它们进行深度拷贝，然后再把副本传出去。
* 字符值如何转化为切片字节，查看runtime包中一个名叫stringtoslicebyte的函数。

	```	
	// 字符变量转化为切片字节
	s := "ab"
	var b1 = []byte(s)
	fmt.Println(cap(b1))
	// 输出 32
	
	var b2 = []byte("ab")
	fmt.Println(cap(b2))
	// 输出 2	
	```