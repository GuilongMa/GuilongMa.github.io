---

layout: single  
title: "数组与链表"  
date: 2022-05-23 17:57:00 +0800   
categories: algorithm

---

# 数组

* 数组（Array）是一种**线性表**数据结构。它用一组**连续的**内存空间，来存储一组具有**相同类型**的数据。
* **线性表**就是数据排成**像一条线一样的结构**。每个线性表上的数据最多只有**前和后两个方向**。其实除了数组，链表、队列、栈等也是线性表结构。
* 非线性表，比如二叉树、堆、图等。
* 数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。
*  数据因为存储是连续的内存空间，插入和删除元素操作需要进行数据搬移，故头部和中间插入和删除为O(n)，尾插入和删除为O(1)（数组如果动态扩容或缩容的话，需要涉及旧数据的拷贝用均摊分析法可得平均为O(1)）。
* 容器类是对数组的增删改查涉及到的底层的内存申请，分配等操作的封装。

# 链表

* 链表的头部插入和删除为O(1),中部和尾部访问、插入和删除第k个元素时需要遍历k-1个元素，故遍历时间复杂度为O(n),但插入和删除这一操作为O(1)。
* 链表**按元素查找进行修改或者删除**同样需要从头遍历，为O(n)，修改和删除这一操作为O(1)。
* 链表**删除（或者插入）给定指针指向的结点**：单向链表：O（n），双向链表：O（1）。
* LRU （最近最久未使用）缓存淘汰算法：我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。1. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。2. 如果此数据没有在缓存链表中，又可以分为两种情况：如果此时缓存未满，则将此结点直接插入到链表的头部；如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。
	* 单向链表实现：缓存访问的时间复杂度为 O(n)。优化：引入散列表（Hash table）+ 双向链表 来记录每个数据的位置，将缓存访问的时间复杂度降到 O(1)。
* 如果我们引入哨兵结点，在任何时候，不管链表是不是空，head 指针都会一直指向这个哨兵结点。我们也把这种有哨兵结点的链表叫带头链表。相反，没有哨兵结点的链表就叫作不带头链表。

# 数组和链表比较

* 数组适合读操作多，写操作少、访问效率高、固定大小数据块的场景，对缓存友好，链表适合插入和删除操作多的场景，会产生内存碎片和额外的指针内存。