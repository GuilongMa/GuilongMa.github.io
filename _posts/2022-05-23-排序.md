---

layout: single  
title: "排序"  
date: 2022-05-23 20:57:00 +0800   
categories: algorithm

---

* 排序的过程就是增加有序度，减少逆序度的过程，逆序度=满有序度-有序度。
* 基于比较的排序算法：冒泡，插入，选择，归并，快速。排序时元素的交换或者移动次数固定，等于逆序度。
* 种类：冒泡，插入，选择，归并，快速，计数，基数排序，桶排序等。
* 时间复杂度O(n²)：冒泡，插入，选择
* 时间复杂度O(nlogn)：归并，快速
* 时间复杂度O(n)：计数，桶排序，基数排序
* 原地排序（空间复杂度为O(1)）：冒泡，插入，选择，快速
* 稳定排序：冒泡，插入，归并，基数，桶排序，计数排序
* 插入排序：分为已排序区间和未排序区间，插入排序的优化：希尔排序。
* 从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。故优先选择插入排序。
* 归并排序：采用分治思想，分治是一种解决问题的处理思想，递归是一种编程技巧，两种并不冲突。一般用递归实现归并。归并排序的执行效率与要排序的原始数组的有序程度无关，故其时间复杂度是非常稳定的，不管最好，最坏还是平均情况，时间复杂度都为O(nlogn)，空间复杂度为O(n)。
	* 递推公式：`merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))`
	* 终止条件：`p >= r` 不用再继续分解 
* 快速排序：也采用分治思想，获取分区点可以采用单边循环法或者双边循环法。快速排序最坏时间复杂度为O（n²）。
	* 递推公式：`quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1… r)`
	* 终止条件：`p >= r `
* 分区点取值法：三数取中法（首，中，尾三个数的中间值为分区点），随机法。
* 归并和快速的区别：归并排序的处理过程是由下到上，先处理子问题，再合并，而快排的处理过程是由上到下，先分区，再处理子问题。
* 桶排序：线性排序，非基于比较的排序算法，不涉及元素间的比较操作。
	* 核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。 
	* 如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k=n/m 个元素。每个桶内部使用快速排序，时间复杂度为 O(k * logk)。m 个桶排序的时间复杂度就是 O(m * k * logk)，因为 k=n/m，所以整个桶排序的时间复杂度就是 O(n*log(n/m))。当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。 
	* 适用场景：排序数据能容易划分为m个桶，桶与桶之间是有顺序的。还有，各个桶之间的数据分布是均匀比较的，若不均匀，时间复杂度可能退化为O(nlogn)，因为各个桶内的数据是用快速排序的。桶排序适合用在外部排序中，即数据量较大，无法全部加载到内存中。
* 计数排序：是桶排序的一种特殊情况，当排序的数据所处的范围不大时，即范围k（k表示桶的个数）远小于数据量n，只能给非负整数排序。
* 基数排序：需要可以分割出来的“位”来比较，而且位之间有递进关系，位的取值范围不能太大，位排序的排序算法要是稳定的，位排序可以用桶排序或计数排序来排序，否则基数排序无法做到O(n)。
* GO标准库内部的排序包的实现？待补充