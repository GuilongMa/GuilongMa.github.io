---

layout: single  
title: "Bufio"  
date: 2022-05-14 12:54:00 +0800   
categories: Go Go-Base

---

* bufio.Reader类型值中的缓冲区起着怎样的作用？
	* bufio.Reader类型的值（以下简称Reader值）内的缓冲区，其实就是一个数据存储中介，它介于底层读取器与读取方法及其调用方之间。所谓的底层读取器，就是在初始化此类值的时候传入的io.Reader类型的参数值。
	* Reader值的读取方法一般都会先从其所属值的缓冲区中读取数据。同时，在必要的时候，它们还会预先从底层读取器那里读出一部分数据，并暂存于缓冲区之中以备后用。
	* 可以在大多数的时候降低读取方法的执行时间。虽然，读取方法有时还要负责填充缓冲区，但从总体来看，读取方法的平均执行时间一般都会因此有大幅度的缩短。

* Peek方法的特点是即使读取了缓冲区中的数据，也不会更改已读计数的值。而Read方法会在参数值的长度过大，且缓冲区中已无未读字节时，跨过缓冲区并直接向底层读取器索要数据。
* ReadSlice方法会在缓冲区的未读部分中寻找给定的分隔符，并在必要时对缓冲区进行填充。如果在填满缓冲区之后仍然未能找到分隔符，那么该方法就会把整个缓冲区作为第一个结果值返回，同时返回缓冲区已满的错误。
* ReadBytes方法会通过调用ReadSlice方法，一次又一次地填充缓冲区，并在其中寻找分隔符。除非发生了未预料到的错误或者找到了分隔符，否则这一过程将会一直进行下去。
* Reader值的ReadLine方法会依赖于它的ReadSlice方法，而其ReadString方法则完全依赖于ReadBytes方法。
* Reader值的Peek方法、ReadSlice方法和ReadLine方法都可能会造成其缓冲区中的内容的泄露。因为它们在正常的情况下都会返回直接基于缓冲区的字节切片。
* 在bufio.Reader类型拥有的读取方法中，Peek方法和ReadSlice方法都会调用该类型一个名为fill的包级私有方法。fill方法的作用是填充内部缓冲区。fill方法只要在开始时发现其所属值的已读计数大于0，就会对缓冲区进行一次压缩。

	![bufio.Reader中的缓冲区压缩](/assets/img/bufio.Reader中的缓冲区压缩.png)
	
* bufio.Writer类型值中缓冲的数据什么时候会被写到它的底层写入器？
	* Flush方法保证不会出现重写和漏写的情况。
	* 发现缓冲区中的可写空间不足以容纳新的字节时调用Flush
	* bufio.Writer类型的一些方法有时候还会试图走捷径，跨过缓冲区而直接对接数据供需的双方。

* bufio 包中的 Reader 和 Writer 的主要作用是在已有的 IO 读取器或者写入器之上再包一层缓冲区，是面向 IO 操作。而 bytes.Buffer 是基于字节数组的缓冲区，是面向纯内存的。
* 函数或方法签名中的有名结果会在该函数或方法被调用时自动地创建并初始化，其初始化值会是其类型的零值。* bufio.Scanner类型俗称带缓存的扫描器。可以自定义每次扫描的分段边界，默认行边界进行分段。扫描器内部设定的最大缓存容量是64K个字节，即目标内容中的每一段都不能超过64K个字节，否则报错：“token too long”。