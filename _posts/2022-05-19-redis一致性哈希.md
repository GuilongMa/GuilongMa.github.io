---

layout: single  
title: "一致性哈希与Redis并发访问控制"  
date: 2022-05-19 15:57:00 +0800   
categories: Redis Redis-Base

---

# 一致性哈希

* Distributed Hash Table（DHT） 是一种哈希分布方式，其目的是为了克服传统哈希分布在服务器节点数量变化时大量数据迁移的问题。

## 基本原理

* 将哈希空间 [0, 2n-1] 看成一个哈希环，每个服务器节点都配置到哈希环上。每个数据对象通过哈希取模得到哈希值之后，存放到哈希环中顺时针方向第一个大于等于该哈希值的节点上。如下图：
	
	![一致性哈希1](/assets/img/一致性哈希1.jpg)
	
* 一致性哈希在增加或者删除节点时只会影响到哈希环中相邻的节点，例如下图中新增节点 X，只需要将它前一个节点 C 上的数据重新进行分布即可，对于节点 A、B、D 都没有影响。

	![一致性哈希2](/assets/img/一致性哈希2.jpg)
	
* 虚拟节点：上面描述的一致性哈希存在数据分布不均匀的问题，节点存储的数据量有可能会存在很大的不同。数据不均匀主要是因为节点在哈希环上分布的不均匀，这种情况在节点数量很少的情况下尤其明显。解决方式是通过增加虚拟节点，然后将虚拟节点映射到真实节点上。虚拟节点的数量比真实节点来得多，那么虚拟节点在哈希环上分布的均匀性就会比原来的真实节点好，从而使得数据分布也更加均匀。

# Redis并发访问控制

为了保证并发访问的正确性，Redis 提供了两种方法，分别是分布式加锁和原子操作。

## 原子操作

* “读取 - 修改 - 写回”操作（Read-Modify-Write，简称为 RMW 操作）。当有多个客户端对同一份数据执行 RMW 操作的话，我们就需要让 RMW 操作涉及的代码以原子性方式执行。
* 相比加锁，原子操作对系统并发性能的影响较小。
* Redis 提供了 INCR/DECR 命令，把RMW 三个操作转变为一个原子操作了。INCR/DECR 命令可以对数据进行增值 / 减值操作。
* 如果我们要执行的操作不是简单地增减数据，而是有更加复杂的判断逻辑或者是其他操作，那么，Redis 的单命令操作已经无法保证多个操作的互斥执行了。所以，这个时候，我们需要使用第二个方法，也就是**Lua 脚本**。使用 Redis 的 EVAL 命令来执行脚本。
* 在编写 Lua 脚本时，你要避免把不需要做并发控制的操作写入脚本中。

## 分布式锁

* 分布式锁用于分布式不同节点间的进程同步。
* 加锁和释放锁的操作就变成了读取、判断和设置共享存储系统中的锁变量值。

### 数据库的唯一索引

* 获得锁时向表中插入一条记录，释放锁时删除这条记录。唯一索引可以保证该记录只被插入一次，那么就可以用这个记录是否存在来判断是否处于锁定状态。
* 存在以下几个问题：
	* 锁没有失效时间，解锁失败的话其它进程无法再获得该锁；
	* 只能是非阻塞锁，插入失败直接就报错了，无法重试；
	* 不可重入，已经获得锁的进程也必须重新获取锁。

###  基于单个 Redis 节点实现分布式锁：Redis 的 SETNX 指令

* 使用 SETNX（set if not exist）指令插入一个键值对，如果 Key 已经存在，那么会返回 False，否则插入成功并返回 True。
* 用 SETNX 和 DEL 命令组合来实现加锁和释放锁操作。
* 在加锁操作时，可以让每个客户端给锁变量设置一个唯一值，这里的唯一值就可以用来标识当前操作的客户端。在释放锁操作时，客户端需要判断，当前锁变量的值是否和自己的唯一标识相等，只有在相等的情况下，才能释放锁。这样一来，就不会出现误释放锁的问题了。
* EXPIRE 指令可以为一个键值对设置一个过期时间，从而避免了数据库唯一索引实现方式中释放锁失败的问题。
* `SET key value [EX seconds | PX milliseconds]  [NX]`来代替SETNX（value默认为1，0值）的功能，使value可设置。
* 为了`SET key value [EX seconds | PX milliseconds]  [NX]`对应到解锁（包含了读取锁变量值、判断锁变量值和删除锁变量三个操作）是原子性操作，应该用Lua脚本实现判断锁变量的值，是否等于执行释放锁操作的客户端的唯一标识。发送此脚本到redis服务器上执行。

### 基于多个Redis 节点实现高可靠的分布式锁：Redis 的 RedLock 算法

* 使用了多个 Redis 实例来实现分布式锁，这是为了保证在发生单点故障时仍然可用。
	* 尝试从 N 个互相独立 Redis 实例获取锁；
	* 计算获取锁消耗的时间，只有时间小于锁的过期时间，并且从大多数（大于等于N / 2 + 1）实例上获取了锁，才认为获取锁成功；
	* 如果获取锁失败，就到每个实例上释放锁。

### Zookeeper 的有序节点

* 待补充

