---

layout: single  
title: "数据库原理之事务与锁"  
date: 2022-05-16 20:17:00 +0800   
categories: Mysql Mysql-Base

---

# 事务
* ​**事务**：满足**ACID特性**的一组操作，可以通过commit进行提交一个事务，也通过Rollback进行回滚。
	* **原子性**（Atomicity）：事务为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。回滚可以用**回滚日志（Undo Log）**来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。
	* **一致性**（Consistency）：**数据库在事务执行前后保持一致性状态。一致性状态指指系统从一个正确的状态,迁移到另一个正确的状态，这需要依赖我们开发者编写不违反数据库约束等规则（应用层面业务的约束或者数据库字段数据类型的约束）的事务代码，开发者通过事务的AID来保证事务的一致性.**
	* **隔离性**（Isolation）：一个事务所做的修改在最终提交以前，对其它事务是不可见的。
	* **持久性**（Durability）：一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不会丢失。系统发生奔溃可以用**重做日志（Redo Log）**进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。

* 无并发->事务串行执行->隔离性满足，此时事务再+满足原子性->满足一致性。
* 并发->事务并行执行，事务满足原子性+满足隔离性->满足一致性。
* **并发一致性问题**：
	* **丢失修改**：指一个事务的更新操作被另外一个事务的更新操作替换。比如事务T1提交的修改被T2提交的修改覆盖，当T1再次读取时之前的修改丢失。**可以通过锁解决**：事务T1修改要加X锁，直到释放X锁之后T2事务才能执行修改。（X1锁对X2锁的排斥，即一级封锁协议）
	* **读脏数据**：指在不同的事务下，当前事务可以读到另外事务未提交的数据。比如T1修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。**可以通过锁解决**：T1事务修改要加X锁，保证提交后再释放X锁，而T2事务读取要加S锁，在X锁还没释放下，无法加S锁，即无法读取T1事务未提交的修改，即可能会回滚的脏数据。（X锁对S锁的排斥，即二级封锁协议）
	* **不可重复读**：指在一个事务内多次读取同一数据集合。比如T1 分两次读取数据，而T2在两次之间对该数据做了修改。 **可以通过锁解决**：读取数据的T1事务要加S锁，故在S锁还没释放的情况下，T2事务无法加X锁对数据进行修改。（S锁对X锁的排斥，即三级封锁协议）
	* **幻影读**：属于不可重复读情况，但读取为范围读取。**可以通过锁解决**：将加锁和解锁分为两个阶段进行。比如lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)（即两段锁协议）。注意：事务遵循两段锁协议是保证可串行化调度的充分条件，但不是必要条件。比如lockx(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)不满足两段锁协议，但它还是可串行化调度。
* 事务的隔离级别：
	* 读未提交（READ UNCOMMITTED）
	* 读已提交（READ COMMITTED）
	* 可重复读（REPEATABLE READ）
	* 可串行化（SERIALIZABLE）：“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。（事务的串行化）
	
# 锁

* 封锁粒度：全局锁，表级锁，行级锁。
	* **全局锁**：就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。全局锁的典型使用场景是，做全库逻辑备份。 一般不用全局锁进行全库逻辑备份，而是用官方自带的逻辑备份工具是 mysqldump。当 mysqldump 使用参数–single-transaction 的时候，导数据之前就会启动一个事务（可重复读隔离级别下），来确保拿到一致性视图。
	* **表级锁**：分为表锁和元数据锁（meta data lock，MDL)。
		* MDL 不需要显式使用，在访问一个表的时候会被自动加上。
		* 在 MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。
	* **行级锁**：
		* **两阶段锁协议**：**在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。**（保证了事务串行化执行，即可串行化隔离级别）
		* 
* 封锁协议：一级封锁协议；二级封锁协议；三级封锁协议，两段锁协议。
* 封锁类型：读写锁，意向锁（IX/IS 都是表锁）。
* 任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；
* X锁的互斥是针对锁定的对象的，故两个事务可以对两个数据行加 X 锁。
* 死锁和死锁检测：
	* 策略1:直接进入等待，直到超时退出线程。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。
	* 策略2:发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。 

# MVCC多版本并发控制

* MVCC多版本并发控制：是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现**提交读和可重复读**这两种隔离级别。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。
* MVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来。当系统里没有比这个回滚日志更早的 read-view 的时候，Undo日志会被删除。
* 回滚日志只有一个？共用？只会删除回滚段？
*  一致性读视图（consistent ReadView）：由事务数组（TRX_IDs {TRX_ID_1, TRX_ID_2, ...}）和高水位（TRX_ID_MAX+1）组成。
	
	![数据版本可见性规则](/assets/img/数据版本可见性规则.png)
	
	**注意：****图中黄色部分包括未提交事务集合和已提交事务集合（事务id比绿色部分的大）**
	
	* 对于当前事务的启动瞬间来说，一个数据版本的 row trx_id，有以下几种可能：
	* 如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；
	* 如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；
	* 如果落在黄色部分，那就包括两种情况：
		* a.  若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；
		* b.  若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。
	
*  数据版本的可见性规则，就是基于数据行的 row trx_id 和上面的一致性视图的对比结果得到的。
*  低水位：TRX_ID_MIN。
* **快照读**：在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读。
*  **当前读（是靠加x锁去实现的）**：MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT （快照读，不需要加读锁）的加锁操作。
*  一般select为快照读，若手动加读写锁的话，会变成当前读。比如以下为当前读：
	
	```
	SELECT * FROM table WHERE ? lock in share mode;
	SELECT * FROM table WHERE ? for update;
	```
* 在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。
* 总结，对于InnoDB中的两种事务隔离级别读已提交和可重复读的适用：一个数据版本，对于一个事务视图来说，除了**自己的更新**总是可见以外，有三种情况：
	* 版本未提交，不可见；
	* 版本已提交，但是是在视图创建后提交的，不可见；
	* 版本已提交，而且是在视图创建前提交的，可见。
	
# MVCC与手动读写锁的区别

 * **产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。**
 * MySQL隐式锁定：MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻（事务提交后）被释放，这被称为隐式锁定。
* MySQL的显式锁定：
	
	```
	SELECT ... LOCK In SHARE MODE;
	SELECT ... FOR UPDATE;
	```
* 加锁能解决多个事务同时执行时出现的并发一致性问题。在实际场景中读操作往往多于写操作，因此又引入了读写锁来避免不必要的加锁操作，例如读和读没有互斥关系。读写锁中读和写操作仍然是互斥的，而 MVCC 利用了多版本的思想，写操作加锁更新最新的版本快照，而读操作（不需要读锁）去读旧版本快照，没有互斥关系，**即MVCC相比读写锁减少了读锁**。
* for update 体现了悲观锁，仅适用于InnoDB，并且必须开启事务，在begin与commit之间才生效。
* InnoDB行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁，有索引/主键但没有查询到数据的话不加锁
* 由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。

# Next-Key-Locks 
 
* Next-Key-Locks：MySQL 的 InnoDB 存储引擎的一种锁实现，MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。
* Record Locks：锁定一个记录上的索引，而不是记录本身。如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。
* Gap Locks：锁定索引之间的间隙，但是不包含索引本身。
锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。
	```
	SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;
	```
* Next-Key-Locks:Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个前开后闭区间。