---

layout: single  
title: "Function，struct，interface and point"  
date: 2022-05-09 13:09:00 +0800   
categories: Go Go-Base

---
# Function

* 在 Go 语言中，函数可是一等的（first-class）公民，函数类型也是一等的数据类型。
* Go 语言这种静态类型的编程语言，我们在定义闭包函数的时候只能知道自由变量的类型。
* 闭包的意义：动态的生成部分逻辑代码。  

# Struct

* 结构体嵌入字段：嵌入字段的类型既是类型也是名称。比如：
	
	```
	type AnimalCategory struct { 
		kingdom string // 界。  
		phylum string // 门。  
		class  string // 纲。  
		order  string // 目。  f
		amily string // 科。  
		genus  string // 属。  
		species string // 种。
	 }
	type Animal struct {
	  scientificName string // 学名。
	  AnimalCategory    // 动物基本分类。
	}
	```
* 当外部结构体不存在相同名字的字段或者方法时，嵌入字段的内部字段和方法可以被“继承”，否则，会被屏蔽。
* 如果处于同一个层级的多个嵌入字段拥有同名的字段或方法，那么从被嵌入类型的值那里，选择此名称的时候就会引发一个编译错误，因为编译器无法确定被选择的成员到底是哪一个。
* 通过嵌入字段的方式实现了类型之间的组合。这样做的具体原因和理念请见 Go 语言官网的 FAQ 中的[Why is there no type inheritance?。](https://go.dev/doc/faq#inheritance)
* 类型之间的组合采用的是非声明的方式，我们不需要显式地声明某个类型实现了某个接口，或者一个类型继承了另一个类型。Go 语言可以轻而易举地通过嵌入多个字段来实现功能强大的类型，却不会有多重继承那样复杂的层次结构和可观的管理成本。
* 理解组合和继承的区别：当内嵌一个类型时，该类型的方法会成为外部类型的方法， 但当它们被调用时，该方法的接收者是内部类型，而非外部的。
* 接口类型之间也可以组合。在 Go 语言中，接口类型之间的组合甚至更加常见，我们常常以此来扩展接口定义的行为或者标记接口的特征。
* **值方法和指针方法区别**：
	* 值方法的接收者是该方法所属的那个类型值的一个副本。我们在该方法内对该副本的修改一般都不会体现在原值上，除非这个类型本身是某个引用类型（比如切片或字典）的别名类型。而指针方法的接收者，是该方法所属的那个基本类型值的指针值的一个副本。我们在这样的方法内对该副本指向的值进行修改，却一定会体现在原值上。
	* 一个自定义数据类型的方法集合中仅会包含它的所有值方法，而该类型的指针类型的方法集合却囊括了前者的所有方法，包括所有值方法和所有指针方法。但是，Go 语言会适时地为我们进行自动地转译(非接口实现情况下)，使得我们在这样的值上也能调用到它的指针方法。
	* 字面量struct{}代表了空的结构体类型。这样的类型既不包含任何字段也没有任何方法。该类型的值所需的存储空间几乎可以忽略不计。因此，我们可以把这样的值作为占位值来使用。比如：在同一个应用场景下，map[int]struct{} 类型的值会比 map[int]bool 类型的值占用更少的存储空间。

# Interface

* 接口类型与其他数据类型不同，它是没法被实例化的。既不能通过调用new函数或make函数创建出一个接口类型的值，也无法用字面量来表示一个接口类型的值，只能通过声明后被赋值。
* 接口类型为静态类型，被赋值的类型为动态类型。
* 如果我们使用一个变量给另外一个变量赋值，那么真正赋给后者的，并不是前者持有的那个值，而是该值的一个副本。
* 接口类型值的存储方式和结构：
	* 数据结构：iface，iface的实例会包含两个指针，一个是指向类型信息的指针，另一个是指向动态值的指针。这里的类型信息是由另一个专用数据结构的实例承载的，其中包含了动态值的类型，以及使它实现了接口的方法和调用它们的途径，等等。
	* 把一个有类型的nil赋给接口变量，那么这个变量的值就一定不会是那个真正的nil。因此，当我们使用判等符号==判断pet是否与字面量nil相等的时候，答案一定会是false。
* 接口之间的组合：只要组合的接口之间有同名的方法就会产生冲突，从而无法通过编译，即使同名方法的签名彼此不同也会是如此。因此，接口的组合根本不可能导致“屏蔽”现象的出现。
* 声明体量较小的接口，并建议我们通过这种接口间的组合来扩展程序、增加程序的灵活性。
* 当类型 X 的值可比较且 X 实现 T 时，非接口类型 X 的值 x 和接口类型 T 的值 t 是可比较的。如果 t 的动态类型与 X 相同且 t 的动态值等于 x，则它们相等。
* 问题：如果我们把一个值为nil的某个实现类型的变量赋给了接口变量，那么在这个接口变量上仍然可以调用该接口的方法吗？如果可以，有哪些注意事项？如果不可以，原因是什么？  

	参考解答：值为 nil 的时候也可以调用该接口的方法，前提有两个。 1. 对象方法的是用指针类型实现的（指针方法） 2. 调用的方法不能依赖该对象（不能访问对象的属性） 为什么需要前提1？ 因为是方法是为指针实现，指针可以指向 nil；但是如果是结构体，空值是 {}。（结构体的*X和X的零值不一样，一个是nil，另一个是X｛｝） 为什么需要前提2？ 这一点应该很好理解，不依赖这个对象就不需要访问与这对象实例相关的内存。通过接口赋值的动态类型，找该类型的注册的函数的地址，然后进行调用即可。
	
# Point

* **指针值**：*类型或者&类型值
* uintptr：一个数值类型，也是 Go 语言内建的数据类型之一。存储 32 位或 64 位的无符号整数，可以代表任何指针的位（bit）模式，也就是原始的内存地址。
* unsafe包中有一个类型叫做Pointer，也代表了“指针”。
* unsafe.Pointer可以表示任何指向可寻址的值的指针，同时它也是前面提到的**指针值**和uintptr值之间的桥梁。也就是说，通过它，我们可以在这两种值之上进行双向的转换。
* Go 语言中的哪些值是不可寻址？（不可变，临时结果，不安全的）
	* 常量的值。
	* 基本类型值的字面量。
	* 算术操作的结果值。
	* 对各种字面量的索引表达式和切片表达式的结果值。不过有一个例外，对切片字面量的索引结果值却是可寻址的。
	* 对字符串变量的索引表达式和切片表达式的结果值。
	* 对字典变量的索引表达式的结果值。
	* 函数字面量和方法字面量，以及对它们的调用表达式的结果值。
	* 结构体字面量的字段值，也就是对结构体字面量的选择表达式的结果值。
	* 类型转换表达式的结果值。
	* 类型断言表达式的结果值。
	* 接收表达式的结果值。

	**注意**：
	
	* 	对切片字面量的索引结果值却是可寻址的。
	* 	针对数组值、切片值或字典值的字面量的表达式会产生临时结果。如果针对的是数组类型或切片类型的变量，那么索引或切片的结果值就都不属于临时结果了，是可寻址的。
	*  对字典类型的变量施加索引表达式，得到的结果值不属于临时结果，可是，这样的值却是不可寻址的。原因是，字典中的每个键 - 元素对的存储位置都可能会变化，而且这种变化外界是无法感知的。
	*  虽然 Go 语言规范中的语法定义是，只要在++或--的左边添加一个表达式，就可以组成一个自增语句或自减语句，但是，它还明确了一个很重要的限制，那就是这个表达式的结果值必须是可寻址的。这就使得针对值字面量的表达式几乎都无法被用在这里。不过这有一个例外，虽然对字典字面量和字典变量索引表达式的结果值都是不可寻址的，但是这样的表达式却可以被用在自增语句和自减语句中。与之类似的规则还有两个。一个是，在赋值语句中，赋值操作符左边的表达式的结果值必须可寻址的，但是对字典的索引结果值也是可以的。另一个是，在带有range子句的for语句中，在range关键字左边的表达式的结果值也都必须是可寻址的，不过对字典的索引结果值同样可以被用在这里。
* 通过unsafe.Pointer操纵可寻址的值：
	*	一个指针值（比如*Dog类型的值）可以被转换为一个unsafe.Pointer类型的值，反之亦然。
	* 一个uintptr类型的值也可以被转换为一个unsafe.Pointer类型的值，反之亦然。
	* 一个指针值无法被直接转换成一个uintptr类型的值，反过来也是如此。
	
		```
		dog := Dog{"little pig"}
		dogP := &dog
		dogPtr := uintptr(unsafe.Pointer(dogP))
		
		namePtr := dogPtr + unsafe.Offsetof(dogP.name)
		nameP := (*string)(unsafe.Pointer(namePtr))
		```
* 从存储和传递的角度看，引用类型的值的指针值没有意义。因为引用类型的值已经相当于指向某个底层数据结构的指针了。当然，引用类型的值不只是指针那么简单。
